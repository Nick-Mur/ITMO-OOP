# Лабораторная работа 3: Управление заказами в службе доставки

В данном проекте разработана система управления заказами с использованием объектно-ориентированного подхода и паттернов проектирования.

## Реализованные паттерны проектирования

В соответствии с заданием, в проекте реализовано 5 паттернов проектирования. Ниже приведено описание каждого из них с обоснованием выбора.

### 1. Facade (Фасад)

*   **Где используется**: Класс `OrdersSystem`.
*   **Как реализован**: Класс `OrdersSystem` предоставляет единый упрощенный интерфейс для взаимодействия со сложной подсистемой управления заказами. Он делегирует вызовы специализированным классам-операциям (`OrderAdder`, `OrderRemover`, `OrderEditor`, `OrderStatusChanger` и др.), скрывая сложность их взаимодействия от клиента.
*   **Почему выбран**: Система управления заказами состоит из множества мелких операций. Чтобы клиентский код (например, UI или тесты) не зависел от десятка мелких классов и не знал деталей их инициализации, был введен Фасад. Это упрощает использование системы и снижает связанность.

### 2. Strategy (Стратегия)

*   **Где используется**: Расчет стоимости заказа (`IPriceCalculationStrategy`).
*   **Как реализован**: Интерфейс `IPriceCalculationStrategy` определяет метод `CalculatePrice`. Конкретные стратегии (`StandardPriceStrategy`, `FastDeliveryPriceStrategy`) реализуют различные алгоритмы расчета (например, добавление наценки за быструю доставку). Контекст (`Order`) хранит ссылку на стратегию и использует её при вызове `GetTotalPrice`.
*   **Почему выбран**: Способ расчета цены может меняться в зависимости от типа заказа (обычный, быстрый, VIP) или акций. Паттерн Стратегия позволяет легко добавлять новые алгоритмы ценообразования, не изменяя код самого заказа, соблюдая принцип открытости/закрытости (OCP).

### 3. State (Состояние)

*   **Где используется**: Управление статусом заказа (`IOrderState`).
*   **Как реализован**: Интерфейс `IOrderState` определяет методы для переходов (`Next`, `Cancel`). Конкретные состояния (`NewState`, `CookingState`, `DeliveryState`, `CompletedState`) реализуют логику переходов и поведение заказа в конкретном статусе. Класс `Order` делегирует управление переходами текущему объекту-состоянию.
*   **Почему выбран**: Заказ имеет жизненный цикл со строгими правилами переходов (нельзя отменить доставленный заказ, нельзя перескочить из "Нового" сразу в "Доставлен"). Паттерн Состояние позволяет инкапсулировать логику переходов в отдельные классы, избавляя код от громоздких конструкций `switch/if` и делая логику переходов явной и безопасной.

### 4. Builder (Строитель)

*   **Где используется**: Создание заказа (`OrderBuilder`).
*   **Как реализован**: Класс `OrderBuilder` предоставляет методы для пошаговой настройки заказа (`SetType`, `AddDish`). Метод `Build` возвращает готовый объект `Order`. Строитель также берет на себя логику выбора правильной стратегии в зависимости от типа заказа.
*   **Почему выбран**: Процесс создания заказа может быть сложным: нужно установить тип, добавить блюда, проверить наличие в меню, назначить начальный статус. Строитель упрощает этот процесс, делая клиентский код более читаемым и позволяя создавать различные конфигурации заказов через один интерфейс.

### 5. Observer (Наблюдатель)

*   **Где используется**: Уведомления об изменении статуса заказа (`IOrderObserver`).
*   **Как реализован**: Интерфейс `IOrderObserver` имеет метод `Update`. Класс `Order` (субъект) хранит список наблюдателей и уведомляет их при изменении состояния через метод `NotifyObservers`. Реализован `ConsoleLoggerObserver` для логирования изменений.
*   **Почему выбран**: Системе часто требуется реагировать на изменение статуса заказа (отправить SMS клиенту, записать лог, обновить UI). Паттерн Наблюдатель позволяет добавлять неограниченное количество обработчиков событий без изменения кода самого заказа, обеспечивая слабую связанность.
